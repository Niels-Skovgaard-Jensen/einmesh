{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"README","text":""},{"location":"#einops-style-multi-dimensional-meshgrids","title":"einops-style multi dimensional meshgrids","text":""},{"location":"#installation","title":"Installation","text":"<p>Simple installation from uv: <pre><code>uv add einmesh\n</code></pre> or pip: <pre><code>pip install einmesh\n</code></pre></p>"},{"location":"#features","title":"Features","text":"<ul> <li>einops-style Meshgrid Generation: The core function <code>einmesh</code> allows creating multi-dimensional meshgrids (like <code>torch.meshgrid</code>) using a concise string pattern similar to <code>einops</code>.</li> <li>Flexible Space Definitions: Users define the dimensions using various \"space\" objects:<ul> <li><code>LinSpace</code>: Linearly spaced points.</li> <li><code>LogSpace</code>: Logarithmically spaced points.</li> <li><code>UniformDistribution</code>: Points sampled from a uniform distribution.</li> <li><code>NormalDistribution</code>: Points sampled from a normal distribution.</li> </ul> </li> <li>Pattern Features:<ul> <li>Named Dimensions: Pattern elements correspond to keyword arguments (e.g., <code>einmesh(\"x y\", x=LinSpace(...), y=LogSpace(...))</code>).</li> <li>Dimension Ordering: The order in the pattern determines the order/shape of the output tensors (using <code>ij</code> indexing convention, like NumPy).</li> <li>Stacking (<code>*</code>): A <code>*</code> in the pattern stacks the individual coordinate tensors along a new dimension, returning a single tensor.</li> <li>Grouping (<code>()</code>): Parentheses group axes for rearrangement using <code>einops.rearrange</code>.</li> <li>Duplicate Names: Handles patterns like <code>\"x x y\"</code>, which repeats an axis and re-samples it.</li> </ul> </li> <li>Output:<ul> <li>Returns a tuple of coordinate tensors if no <code>*</code> is present.</li> <li>Returns a single stacked tensor if <code>*</code> is present.</li> </ul> </li> <li>Backend: Numpy, Torch and JAX are all supported! Just import the einmesh function from the backend like <pre><code>from einmesh.numpy import einmesh # Creates numpy arrays\nfrom einmesh.jax import einmesh # Creates JAX arrays\nfrom einmesh.torch import einmesh # Creates Torch Tensors\n</code></pre></li> <li>Super-Lightweight: Only installation dependency is einops! At runtime backends are loaded if available.</li> </ul>"},{"location":"#examples","title":"Examples","text":"<p>1. Basic 2D Linear Grid</p> <p>Create a simple 2D grid with linearly spaced points along x and y.</p> <pre><code>from einmesh import LinSpace\nfrom einmesh.numpy import einmesh\n\n# Define the spaces\nx_space = LinSpace(0, 1, 10)  # 10 points from 0 to 1\ny_space = LinSpace(-1, 1, 20) # 20 points from -1 to 1\n\n# Create the meshgrid\n# Output: tuple of two tensors, each with shape (10, 20) following 'ij' indexing\nx_coords, y_coords = einmesh(\"x y\", x=x_space, y=y_space)\n\nprint(f\"{x_coords.shape=}\")\nprint(f\"{y_coords.shape=}\")\n\n# Output:\n# x_coords.shape=(10, 20)\n# y_coords.shape=(10, 20)\n</code></pre> <p>2. Stacked Coordinates</p> <p>Create a 3D grid and stack the coordinate tensors into a single tensor.</p> <pre><code>x_space = LinSpace(0, 1, 5)\ny_space = LinSpace(0, 1, 6)\nz_space = LogSpace(1, 2, 7)\n\n# Use '*' to stack the coordinates along the last dimension\n# Output: single tensor with shape (5, 6, 7, 3)\ncoords = einmesh(\"x y z *\", x=x_space, y=y_space, z=z_space)\n\nprint(coords.shape)\n# Output: (5, 6, 7, 3)\n# coords[..., 0] contains x coordinates\n# coords[..., 1] contains y coordinates\n# coords[..., 2] contains z coordinates\n</code></pre> <p>3. Using Distributions</p> <p>Generate grid points by sampling from distributions.</p> <pre><code>from einmesh import UniformDistribution, NormalDistribution\n\n# Sample 10 points uniformly between -5 and 5 for x\nx_dist = UniformDistribution(-5, 5, 10)\n# Sample 15 points from a normal distribution (mean=0, std=1) for y\ny_dist = NormalDistribution(0, 1, 15)\n\n# Create the meshgrid\n# Output: tuple of two tensors, each with shape (10, 15)\nx_samples, y_samples = einmesh(\"x y\", x=x_dist, y=y_dist)\n\nprint(x_samples.shape, y_samples.shape)\n# Output: (10, 15) (10, 15)\n# Note: The points along each axis will not be sorted.\n</code></pre> <p>4. Duplicate Dimension Names</p> <p>Use the same space definition for multiple axes.</p> <pre><code>space = LinSpace(0, 1, 5)\n\n# 'x' space is used for both the first and second dimensions.\n# Output shapes: (5, 5, 10) for each tensor\nx0_coords, x1_coords, y_coords = einmesh(\"x x y\", x=space, y=LinSpace(-1, 1, 10))\n\nprint(x0_coords.shape, x1_coords.shape, y_coords.shape)\n# Output: (5, 5, 10) (5, 5, 10) (5, 5, 10)\n</code></pre>"},{"location":"jax/","title":"jax","text":"Source code in <code>src/einmesh/jax.py</code> <pre><code>def einmesh(pattern: str, **kwargs: SpaceType) -&gt; jax.Array:\n    return _einmesh(pattern, backend=JaxBackend(), **kwargs)  # pyright: ignore[reportReturnType]\n</code></pre>"},{"location":"numpy/","title":"numpy","text":""},{"location":"numpy/#einmesh.numpy.EinMesher","title":"<code>EinMesher</code>","text":"<p>               Bases: <code>_EinMesher</code></p> <p>EinMesher bound to the NumPy backend. By default <code>.mesh()</code> will return NumPy arrays without needing to pass a backend.</p> Source code in <code>src/einmesh/numpy.py</code> <pre><code>class EinMesher(_EinMesher):\n    \"\"\"\n    EinMesher bound to the NumPy backend. By default `.mesh()` will return NumPy arrays\n    without needing to pass a backend.\n    \"\"\"\n\n    def __init__(self, pattern: str, **spaces: SpaceType) -&gt; None:\n        super().__init__(pattern, backend=NumpyBackend(), **spaces)\n\n    def sample(self) -&gt; np.ndarray[Any, Any] | tuple[np.ndarray[Any, Any], ...]:\n        return super().sample()\n</code></pre>"},{"location":"numpy/#einmesh.numpy.einmesh","title":"<code>einmesh(pattern, *unamed_spaces, **named_spaces)</code>","text":"<p>Numpy einmesh function.</p> Source code in <code>src/einmesh/numpy.py</code> <pre><code>def einmesh(\n    pattern: str, *unamed_spaces: SpaceType, **named_spaces: SpaceType\n) -&gt; np.ndarray[Any, Any] | tuple[np.ndarray[Any, Any], ...]:\n    \"\"\"\n    Numpy einmesh function.\n    \"\"\"\n    return _einmesh(pattern, *unamed_spaces, backend=NumpyBackend(), **named_spaces)\n</code></pre>"},{"location":"spaces/","title":"Spaces","text":""},{"location":"spaces/#einmesh.spaces.ConstantSpace","title":"<code>ConstantSpace</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SpaceType</code></p> <p>Represents a constant value repeated multiple times.</p> <p>This class generates a tensor containing the same constant value repeated <code>num</code> times.</p> <p>Attributes:</p> Name Type Description <code>value</code> <code>float</code> <p>The constant float value to be used.</p> <code>num</code> <code>int | None</code> <p>The number of times the constant value should be repeated. Defaults to 1.</p> Source code in <code>src/einmesh/spaces.py</code> <pre><code>@dataclass\nclass ConstantSpace(SpaceType):\n    \"\"\"\n    Represents a constant value repeated multiple times.\n\n    This class generates a tensor containing the same constant value repeated\n    `num` times.\n\n    Attributes:\n        value: The constant float value to be used.\n        num: The number of times the constant value should be repeated. Defaults to 1.\n    \"\"\"\n\n    value: float\n    num: int | None = None\n\n    def __post_init__(self) -&gt; None:\n        if self.num is None:\n            object.__setattr__(self, \"num\", 1)\n\n    def _generate_samples(self, backend: AbstractBackend):\n        \"\"\"Generates a tensor with the constant value repeated.\"\"\"\n        return backend.full((self.num,), self.value)\n</code></pre>"},{"location":"spaces/#einmesh.spaces.ConstantSpace._generate_samples","title":"<code>_generate_samples(backend)</code>","text":"<p>Generates a tensor with the constant value repeated.</p> Source code in <code>src/einmesh/spaces.py</code> <pre><code>def _generate_samples(self, backend: AbstractBackend):\n    \"\"\"Generates a tensor with the constant value repeated.\"\"\"\n    return backend.full((self.num,), self.value)\n</code></pre>"},{"location":"spaces/#einmesh.spaces.Distribution","title":"<code>Distribution</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SpaceType</code></p> <p>Base class for all distribution spaces.</p> Source code in <code>src/einmesh/spaces.py</code> <pre><code>@dataclass\nclass Distribution(SpaceType):\n    \"\"\"Base class for all distribution spaces.\"\"\"\n\n    ...\n</code></pre>"},{"location":"spaces/#einmesh.spaces.LgSpace","title":"<code>LgSpace</code>  <code>dataclass</code>","text":"<p>               Bases: <code>LogSpace</code></p> <p>Represents a sequence of points spaced in base 2.</p> Source code in <code>src/einmesh/spaces.py</code> <pre><code>@dataclass\nclass LgSpace(LogSpace):\n    \"\"\"\n    Represents a sequence of points spaced in base 2.\n    \"\"\"\n\n    start: float\n    end: float\n    num: int\n    base: float = field(init=False, default=2)\n\n    def __post_init__(self) -&gt; None:\n        object.__setattr__(self, \"base\", 2)\n</code></pre>"},{"location":"spaces/#einmesh.spaces.LinSpace","title":"<code>LinSpace</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SpaceType</code></p> <p>Represents a sequence of points spaced linearly.</p> <p>This class generates a tensor of <code>num</code> points evenly spaced between <code>start</code> and <code>end</code> (inclusive).</p> <p>Attributes:</p> Name Type Description <code>start</code> <code>float</code> <p>The starting value of the sequence.</p> <code>end</code> <code>float</code> <p>The ending value of the sequence.</p> <code>num</code> <code>int</code> <p>The number of points to generate.</p> Source code in <code>src/einmesh/spaces.py</code> <pre><code>@dataclass\nclass LinSpace(SpaceType):\n    \"\"\"\n    Represents a sequence of points spaced linearly.\n\n    This class generates a tensor of `num` points evenly spaced between `start`\n    and `end` (inclusive).\n\n    Attributes:\n        start: The starting value of the sequence.\n        end: The ending value of the sequence.\n        num: The number of points to generate.\n    \"\"\"\n\n    start: float\n    end: float\n    num: int\n\n    def _generate_samples(self, backend: AbstractBackend):\n        \"\"\"Generates the linearly spaced points.\"\"\"\n        return backend.linspace(self.start, self.end, self.num)\n</code></pre>"},{"location":"spaces/#einmesh.spaces.LinSpace._generate_samples","title":"<code>_generate_samples(backend)</code>","text":"<p>Generates the linearly spaced points.</p> Source code in <code>src/einmesh/spaces.py</code> <pre><code>def _generate_samples(self, backend: AbstractBackend):\n    \"\"\"Generates the linearly spaced points.\"\"\"\n    return backend.linspace(self.start, self.end, self.num)\n</code></pre>"},{"location":"spaces/#einmesh.spaces.ListSpace","title":"<code>ListSpace</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SpaceType</code></p> <p>Represents a predefined list of values.</p> <p>This class generates a tensor directly from a provided list of float values. The number of points generated is equal to the length of the input list.</p> <p>Attributes:</p> Name Type Description <code>values</code> <code>list[float]</code> <p>A list of float values to be converted into a tensor.</p> <code>num</code> <code>int</code> <p>The number of points, automatically set to length of values.</p> Source code in <code>src/einmesh/spaces.py</code> <pre><code>@dataclass\nclass ListSpace(SpaceType):\n    \"\"\"\n    Represents a predefined list of values.\n\n    This class generates a tensor directly from a provided list of float values.\n    The number of points generated is equal to the length of the input list.\n\n    Attributes:\n        values: A list of float values to be converted into a tensor.\n        num: The number of points, automatically set to length of values.\n    \"\"\"\n\n    values: list[float]\n    num: int = field(init=False)\n\n    def __post_init__(self) -&gt; None:\n        object.__setattr__(self, \"num\", len(self.values))\n\n    def _generate_samples(self, backend: AbstractBackend):\n        \"\"\"Generates a tensor from the provided list of values.\"\"\"\n        return backend.tensor(self.values)\n</code></pre>"},{"location":"spaces/#einmesh.spaces.ListSpace._generate_samples","title":"<code>_generate_samples(backend)</code>","text":"<p>Generates a tensor from the provided list of values.</p> Source code in <code>src/einmesh/spaces.py</code> <pre><code>def _generate_samples(self, backend: AbstractBackend):\n    \"\"\"Generates a tensor from the provided list of values.\"\"\"\n    return backend.tensor(self.values)\n</code></pre>"},{"location":"spaces/#einmesh.spaces.LnSpace","title":"<code>LnSpace</code>  <code>dataclass</code>","text":"<p>               Bases: <code>LogSpace</code></p> <p>Represents a sequence of points spaced in base e.</p> Source code in <code>src/einmesh/spaces.py</code> <pre><code>@dataclass\nclass LnSpace(LogSpace):\n    \"\"\"\n    Represents a sequence of points spaced in base e.\n    \"\"\"\n\n    start: float\n    end: float\n    num: int\n    base: float = field(init=False, default=math.e)\n\n    def __post_init__(self) -&gt; None:\n        object.__setattr__(self, \"base\", math.e)\n</code></pre>"},{"location":"spaces/#einmesh.spaces.LogSpace","title":"<code>LogSpace</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SpaceType</code></p> <p>Represents a sequence of points spaced logarithmically.</p> <p>This class generates a tensor of <code>num</code> points between <code>10**start</code> and <code>10**end</code> (or <code>base**start</code> and <code>base**end</code> if <code>base</code> is specified), spaced logarithmically.</p> <p>Attributes:</p> Name Type Description <code>start</code> <code>float</code> <p>The starting exponent of the sequence.</p> <code>end</code> <code>float</code> <p>The ending exponent of the sequence.</p> <code>num</code> <code>int</code> <p>The number of points to generate.</p> <code>base</code> <code>float</code> <p>The base of the logarithm. Defaults to 10.</p> Source code in <code>src/einmesh/spaces.py</code> <pre><code>@dataclass\nclass LogSpace(SpaceType):\n    \"\"\"\n    Represents a sequence of points spaced logarithmically.\n\n    This class generates a tensor of `num` points between `10**start` and `10**end`\n    (or `base**start` and `base**end` if `base` is specified), spaced\n    logarithmically.\n\n    Attributes:\n        start: The starting exponent of the sequence.\n        end: The ending exponent of the sequence.\n        num: The number of points to generate.\n        base: The base of the logarithm. Defaults to 10.\n    \"\"\"\n\n    start: float\n    end: float\n    num: int\n    base: float = 10\n\n    def _generate_samples(self, backend: AbstractBackend):\n        \"\"\"Generates the logarithmically spaced points.\"\"\"\n        sample = backend.logspace(self.start, self.end, self.num, base=self.base)\n        return self._apply_operators(sample, backend)\n</code></pre>"},{"location":"spaces/#einmesh.spaces.LogSpace._generate_samples","title":"<code>_generate_samples(backend)</code>","text":"<p>Generates the logarithmically spaced points.</p> Source code in <code>src/einmesh/spaces.py</code> <pre><code>def _generate_samples(self, backend: AbstractBackend):\n    \"\"\"Generates the logarithmically spaced points.\"\"\"\n    sample = backend.logspace(self.start, self.end, self.num, base=self.base)\n    return self._apply_operators(sample, backend)\n</code></pre>"},{"location":"spaces/#einmesh.spaces.NormalDistribution","title":"<code>NormalDistribution</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Distribution</code></p> <p>Represents a sampling from a normal (Gaussian) distribution.</p> <p>This class generates a tensor of <code>num</code> random numbers sampled from a normal distribution with the specified <code>mean</code> and standard deviation <code>std</code>.</p> <p>Attributes:</p> Name Type Description <code>mean</code> <code>float</code> <p>The mean (center) of the normal distribution.</p> <code>std</code> <code>float</code> <p>The standard deviation (spread or width) of the normal distribution.</p> <code>num</code> <code>int</code> <p>The number of samples to generate.</p> Source code in <code>src/einmesh/spaces.py</code> <pre><code>@dataclass\nclass NormalDistribution(Distribution):\n    \"\"\"\n    Represents a sampling from a normal (Gaussian) distribution.\n\n    This class generates a tensor of `num` random numbers sampled from a normal\n    distribution with the specified `mean` and standard deviation `std`.\n\n    Attributes:\n        mean: The mean (center) of the normal distribution.\n        std: The standard deviation (spread or width) of the normal distribution.\n        num: The number of samples to generate.\n    \"\"\"\n\n    mean: float\n    std: float\n    num: int\n\n    def _generate_samples(self, backend: AbstractBackend):\n        \"\"\"Generates samples from the normal distribution.\"\"\"\n        return backend.normal(mean=self.mean, std=self.std, size=(self.num,))\n</code></pre>"},{"location":"spaces/#einmesh.spaces.NormalDistribution._generate_samples","title":"<code>_generate_samples(backend)</code>","text":"<p>Generates samples from the normal distribution.</p> Source code in <code>src/einmesh/spaces.py</code> <pre><code>def _generate_samples(self, backend: AbstractBackend):\n    \"\"\"Generates samples from the normal distribution.\"\"\"\n    return backend.normal(mean=self.mean, std=self.std, size=(self.num,))\n</code></pre>"},{"location":"spaces/#einmesh.spaces.RangeSpace","title":"<code>RangeSpace</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SpaceType</code></p> <p>Return evenly spaced values within a given interval.</p> <p>This class generates a tensor of <code>num</code> points evenly spaced between <code>start</code> and <code>end</code> (inclusive). It works like a arange function of numpy, torch or jax.</p> <p>Attributes:</p> Name Type Description <code>start</code> <code>float</code> <p>The starting value of the sequence.</p> <code>end</code> <code>float</code> <p>The ending value of the sequence.</p> <code>num</code> <code>float</code> <p>The number of points to generate.</p> Source code in <code>src/einmesh/spaces.py</code> <pre><code>@dataclass\nclass RangeSpace(SpaceType):\n    \"\"\"\n    Return evenly spaced values within a given interval.\n\n    This class generates a tensor of `num` points evenly spaced between `start`\n    and `end` (inclusive). It works like a arange function of numpy, torch or jax.\n\n    Attributes:\n        start: The starting value of the sequence.\n        end: The ending value of the sequence.\n        num: The number of points to generate.\n    \"\"\"\n\n    start: float\n    stop: float\n    step: int = 1\n\n    def __post_init__(self) -&gt; None:\n        self.num: int = int((self.stop - self.start) / self.step)\n\n    def _generate_samples(self, backend: AbstractBackend) -&gt; Any:\n        \"\"\"Generates the linearly spaced points using arange.\"\"\"\n        return backend.arange(self.start, self.stop, self.step)\n</code></pre>"},{"location":"spaces/#einmesh.spaces.RangeSpace._generate_samples","title":"<code>_generate_samples(backend)</code>","text":"<p>Generates the linearly spaced points using arange.</p> Source code in <code>src/einmesh/spaces.py</code> <pre><code>def _generate_samples(self, backend: AbstractBackend) -&gt; Any:\n    \"\"\"Generates the linearly spaced points using arange.\"\"\"\n    return backend.arange(self.start, self.stop, self.step)\n</code></pre>"},{"location":"spaces/#einmesh.spaces.SpaceType","title":"<code>SpaceType</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for all space types.</p> Source code in <code>src/einmesh/spaces.py</code> <pre><code>@dataclass\nclass SpaceType(ABC):\n    \"\"\"Base class for all space types.\"\"\"\n\n    operators: list[BackendOperator] = field(init=False, default_factory=list)\n\n    def _with_operator(self, operator: BackendOperator, prepend: bool = False) -&gt; SpaceType:\n        \"\"\"Return a copy of this space with the given operator applied.\"\"\"\n        new_space = deepcopy(self)\n        if prepend:\n            new_space.operators.insert(0, operator)\n        else:\n            new_space.operators.append(operator)\n        return new_space\n\n    def _with_operators(self, operators: list[BackendOperator], prepend: bool = False) -&gt; SpaceType:\n        \"\"\"Return a copy of this space with multiple operators applied.\"\"\"\n        new_space = deepcopy(self)\n        if prepend:\n            new_space.operators = operators + new_space.operators\n        else:\n            new_space.operators.extend(operators)\n        return new_space\n\n    def __abs__(self) -&gt; SpaceType:\n        return self._with_operator(OperatorFactory.abs())\n\n    def __add__(self, other) -&gt; SpaceType:\n        return self._with_operator(OperatorFactory.add(value=other))\n\n    def __radd__(self, other) -&gt; SpaceType:\n        return self.__add__(other)\n\n    def __sub__(self, other) -&gt; SpaceType:\n        return self._with_operator(OperatorFactory.sub(value=other))\n\n    def __rsub__(self, other) -&gt; SpaceType:\n        return self._with_operators(\n            operators=[\n                OperatorFactory.neg(),\n                OperatorFactory.add(value=other),\n            ],\n            prepend=True,\n        )\n\n    def __mul__(self, other) -&gt; SpaceType:\n        return self._with_operator(OperatorFactory.mul(value=other))\n\n    def __rmul__(self, other) -&gt; SpaceType:\n        return self.__mul__(other)\n\n    def __mod__(self, other) -&gt; SpaceType:\n        return self._with_operator(OperatorFactory.mod(value=other))\n\n    def __floordiv__(self, other) -&gt; SpaceType:\n        return self._with_operator(OperatorFactory.floor_div(value=other))\n\n    def __truediv__(self, other) -&gt; SpaceType:\n        return self._with_operator(OperatorFactory.div(value=other))\n\n    def __neg__(self) -&gt; SpaceType:\n        return self._with_operator(OperatorFactory.neg())\n\n    def __pos__(self) -&gt; SpaceType:\n        return self._with_operator(OperatorFactory.pos())\n\n    def __pow__(self, other) -&gt; SpaceType:\n        return self._with_operator(OperatorFactory.pow(exponent=other))\n\n    @abstractmethod\n    def _generate_samples(self, backend: AbstractBackend):\n        \"\"\"Create a new space type.\"\"\"\n        ...\n\n    def _sample(self, backend: AbstractBackend) -&gt; Any:\n        \"\"\"Sample the space type.\"\"\"\n        sample = self._generate_samples(backend)\n        return self._apply_operators(sample, backend)\n\n    def _apply_operators(self, sample, backend: AbstractBackend) -&gt; Any:\n        \"\"\"Apply the operators to the space type.\"\"\"\n        for operator in self.operators:\n            sample = operator._apply(x=sample, backend=backend)\n        return sample\n</code></pre>"},{"location":"spaces/#einmesh.spaces.SpaceType._apply_operators","title":"<code>_apply_operators(sample, backend)</code>","text":"<p>Apply the operators to the space type.</p> Source code in <code>src/einmesh/spaces.py</code> <pre><code>def _apply_operators(self, sample, backend: AbstractBackend) -&gt; Any:\n    \"\"\"Apply the operators to the space type.\"\"\"\n    for operator in self.operators:\n        sample = operator._apply(x=sample, backend=backend)\n    return sample\n</code></pre>"},{"location":"spaces/#einmesh.spaces.SpaceType._generate_samples","title":"<code>_generate_samples(backend)</code>  <code>abstractmethod</code>","text":"<p>Create a new space type.</p> Source code in <code>src/einmesh/spaces.py</code> <pre><code>@abstractmethod\ndef _generate_samples(self, backend: AbstractBackend):\n    \"\"\"Create a new space type.\"\"\"\n    ...\n</code></pre>"},{"location":"spaces/#einmesh.spaces.SpaceType._sample","title":"<code>_sample(backend)</code>","text":"<p>Sample the space type.</p> Source code in <code>src/einmesh/spaces.py</code> <pre><code>def _sample(self, backend: AbstractBackend) -&gt; Any:\n    \"\"\"Sample the space type.\"\"\"\n    sample = self._generate_samples(backend)\n    return self._apply_operators(sample, backend)\n</code></pre>"},{"location":"spaces/#einmesh.spaces.SpaceType._with_operator","title":"<code>_with_operator(operator, prepend=False)</code>","text":"<p>Return a copy of this space with the given operator applied.</p> Source code in <code>src/einmesh/spaces.py</code> <pre><code>def _with_operator(self, operator: BackendOperator, prepend: bool = False) -&gt; SpaceType:\n    \"\"\"Return a copy of this space with the given operator applied.\"\"\"\n    new_space = deepcopy(self)\n    if prepend:\n        new_space.operators.insert(0, operator)\n    else:\n        new_space.operators.append(operator)\n    return new_space\n</code></pre>"},{"location":"spaces/#einmesh.spaces.SpaceType._with_operators","title":"<code>_with_operators(operators, prepend=False)</code>","text":"<p>Return a copy of this space with multiple operators applied.</p> Source code in <code>src/einmesh/spaces.py</code> <pre><code>def _with_operators(self, operators: list[BackendOperator], prepend: bool = False) -&gt; SpaceType:\n    \"\"\"Return a copy of this space with multiple operators applied.\"\"\"\n    new_space = deepcopy(self)\n    if prepend:\n        new_space.operators = operators + new_space.operators\n    else:\n        new_space.operators.extend(operators)\n    return new_space\n</code></pre>"},{"location":"spaces/#einmesh.spaces.UniformDistribution","title":"<code>UniformDistribution</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Distribution</code></p> <p>Represents a sampling from a uniform distribution.</p> <p>This class generates a tensor of <code>num</code> random numbers sampled from a uniform distribution over the interval [<code>low</code>, <code>high</code>).</p> <p>Attributes:</p> Name Type Description <code>low</code> <code>float</code> <p>The lower boundary of the output interval.</p> <code>high</code> <code>float</code> <p>The upper boundary of the output interval.</p> <code>num</code> <code>int</code> <p>The number of samples to generate.</p> Source code in <code>src/einmesh/spaces.py</code> <pre><code>@dataclass\nclass UniformDistribution(Distribution):\n    \"\"\"\n    Represents a sampling from a uniform distribution.\n\n    This class generates a tensor of `num` random numbers sampled from a uniform\n    distribution over the interval [`low`, `high`).\n\n    Attributes:\n        low: The lower boundary of the output interval.\n        high: The upper boundary of the output interval.\n        num: The number of samples to generate.\n    \"\"\"\n\n    low: float\n    high: float\n    num: int\n\n    def _generate_samples(self, backend: AbstractBackend):\n        \"\"\"Generates samples from the uniform distribution.\"\"\"\n        # torch.rand samples from [0, 1), so we scale and shift.\n        return backend.rand(size=(self.num,)) * (self.high - self.low) + self.low\n</code></pre>"},{"location":"spaces/#einmesh.spaces.UniformDistribution._generate_samples","title":"<code>_generate_samples(backend)</code>","text":"<p>Generates samples from the uniform distribution.</p> Source code in <code>src/einmesh/spaces.py</code> <pre><code>def _generate_samples(self, backend: AbstractBackend):\n    \"\"\"Generates samples from the uniform distribution.\"\"\"\n    # torch.rand samples from [0, 1), so we scale and shift.\n    return backend.rand(size=(self.num,)) * (self.high - self.low) + self.low\n</code></pre>"},{"location":"torch/","title":"torch","text":""},{"location":"torch/#einmesh.torch.EinMesher","title":"<code>EinMesher</code>","text":"<p>               Bases: <code>_EinMesher</code></p> <p>EinMesher bound to the Torch backend. By default <code>.mesh()</code> will return PyTorch tensors without needing to pass a backend.</p> Source code in <code>src/einmesh/torch.py</code> <pre><code>class EinMesher(_EinMesher):\n    \"\"\"\n    EinMesher bound to the Torch backend. By default `.mesh()` will return PyTorch tensors\n    without needing to pass a backend.\n    \"\"\"\n\n    def __init__(self, pattern: str, **spaces: SpaceType):\n        super().__init__(pattern, backend=TorchBackend(), **spaces)\n\n    def sample(self) -&gt; torch.Tensor | tuple[torch.Tensor, ...]:\n        return super().sample()\n</code></pre>"},{"location":"notebooks/basics/","title":"Basic Examples of einmesh","text":"<p>This notebook demonstrates the core functionality of einmesh through simple examples. We'll explore:</p> <ol> <li>Creating basic 2D meshgrids using linear spaces</li> <li>Working with 3D grids using different space types (LogSpace and UniformDistribution)</li> <li>Using repeated dimensions in patterns</li> </ol> <p>einmesh provides an intuitive, einops-style syntax for creating multi-dimensional meshgrids, making it easy to define complex coordinate systems with just a few lines of code.</p> <pre><code>import matplotlib.pyplot as plt\n\n# Einmeshes are created from spaces and distribution which are backend agnostic.\nfrom einmesh import (\n    LinSpace,\n    LogSpace,\n    UniformDistribution,\n)\n\n# To use a specific backend, just import the einmesh function from the desired backend.\nfrom einmesh.numpy import einmesh\n# from einmesh.jax import einmesh\n# from einmesh.torch import einmesh\n</code></pre> <p>The first thing to know is the use of einstein notation to create the shapes of the meshgrid that is being generated by einmesh. An einmesh pattern consists of space separated names (\"x y z\"), parenthesis(\"(x y) z\"), stars (\" x y z\") and ellipsis (\" x ...\"). </p> <ul> <li>Names express which dimension should correspond to a keyword Space argument </li> <li>Parenthesis flattens axis into each other, just like einops.rearrange</li> <li>A star tells einmesh to stack the outputs into the dimension of the star, instead of returning a tuple</li> <li>Ellipsis allows for sampling of spaces that are not named in the keyword arguments, but instead are passed as regular arguments</li> </ul> <p>In the below example we showcase this by creating a 2D square mesh between 0 and 1, with 10 points in each dimension.</p> <pre><code>x_coords, y_coords = einmesh(\"x y\", x=LinSpace(start=0, end=1, num=10), y=LinSpace(start=-10, end=10, num=10))\nprint(x_coords.shape, y_coords.shape)\n\nplt.figure(figsize=(5, 4))\nplt.scatter(x_coords, y_coords)\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\nplt.title(\"2D Mesh Grid\")\nplt.show()\n</code></pre> <p>By changing the space type, we change the type of sampling</p> <pre><code>lin_coords, log_coords = einmesh(\n    \"lin log\", lin=LinSpace(start=0, end=1, num=10), log=LogSpace(start=0, end=1, num=10, base=10)\n)\nprint(lin_coords.shape, log_coords.shape)\nplt.figure(figsize=(5, 4))\nplt.scatter(lin_coords, log_coords)\nplt.xlabel(\"lin\")\nplt.ylabel(\"log\")\nplt.title(\"2D Mesh Grid with log space in y\")\nplt.show()\n</code></pre> <p>If one wants to have two dimension that are identically sampled, one can repeat an axis in the pattern. </p> <pre><code>x_coords_repeated, y_coords_repeated = einmesh(\"x x\", x=LinSpace(start=0, end=1, num=10))\nprint(x_coords_repeated.shape, y_coords_repeated.shape)\n</code></pre> <p>If you want the meshgrid to return a stacked tensor, you can use the * operator. The meshgrid will be stacked in the dimensions in which the * is located in the pattern.</p> <pre><code>coords_stacked_start = einmesh(\"* x x\", x=LinSpace(start=0, end=1, num=10))\nprint(f\"{coords_stacked_start.shape=}\")\ncoords_stacked_mid = einmesh(\"x * x\", x=LinSpace(start=0, end=1, num=10))\nprint(f\"{coords_stacked_mid.shape=}\")\ncoords_stacked_end = einmesh(\"x x *\", x=LinSpace(start=0, end=1, num=10))\nprint(f\"{coords_stacked_end.shape=}\")\n</code></pre> <p>In style with einops.rearrange, axis can be combined (flattened), by using a parenthesis.</p> <pre><code>coords_flattened = einmesh(\"* (x y)\", x=LinSpace(0, 1, num=10), y=LinSpace(0, 1, num=10))\nprint(f\"{coords_flattened.shape=}\")\neverything_flattened = einmesh(\"(* x y)\", x=LinSpace(0, 1, num=10), y=LinSpace(0, 1, num=10))\nprint(f\"{everything_flattened.shape=}\")\n</code></pre> <p>The grids that are generated by einmesh be of arbitrary dimensionality, and arbitrary combination of spaces. So if you want to generate a 9D grid, it is as easy as changing the pattern.</p> <pre><code>nine_d_grid = einmesh(\n    \"* x y z w v u t s r\",\n    x=LinSpace(start=0, end=1, num=1),\n    y=LinSpace(start=0, end=1, num=2),\n    z=LogSpace(start=0, end=1, num=3),\n    w=LinSpace(start=0, end=1, num=4),\n    v=LogSpace(start=0, end=1, num=5),\n    u=LinSpace(start=0, end=1, num=6),\n    t=LinSpace(start=0, end=1, num=7),\n    s=UniformDistribution(low=0, high=1, num=8),\n    r=LinSpace(start=0, end=1, num=9),\n)\nprint(f\"{nine_d_grid.shape=}\")\n</code></pre> <p>And you can combine axis as you want</p> <pre><code>nine_d_grid = einmesh(\n    \"x (y z w) v (u t) (* s) r\",\n    x=LinSpace(start=0, end=1, num=1),\n    y=LinSpace(start=0, end=1, num=2),\n    z=LogSpace(start=0, end=1, num=3),\n    w=LinSpace(start=0, end=1, num=4),\n    v=LogSpace(start=0, end=1, num=5),\n    u=LinSpace(start=0, end=1, num=6),\n    t=LinSpace(start=0, end=1, num=7),\n    s=UniformDistribution(low=0, high=1, num=8),\n    r=LinSpace(start=0, end=1, num=9),\n)\nprint(\"Shape should be (x, y*z*w, v, u*t, stacked_dim*s, r)\")\nprint(f\"i.e Shape should be {1, 2 * 3 * 4, 5, 6 * 7, 9 * 8, 9}\")\nprint(f\"{nine_d_grid.shape=}\")\n</code></pre> <p>If you want to create a tensor without having to specify the keywords in the pattern, you can unpack a list of spaces and use the ellipsis function to include them in the pattern.</p> <pre><code>spaces = [LinSpace(1, 1, 5)] * 8  # Some programmatic way to create a list of spaces\n\n# Unpack the list and specify where the ellipsis (unpacking) should be\nnine_d_grid = einmesh(\"* ...\", *spaces)\nprint(nine_d_grid.shape)\n</code></pre> <p>And all of these methods can be combined to your hearts content.</p> <pre><code>from einmesh.spaces import NormalDistribution\n\ntensor = einmesh(\n    \"(x *) (... y) z y w w\",\n    *([LinSpace(1, 1, 5)] * 3),\n    x=LinSpace(0, 2, 3),\n    y=NormalDistribution(0, 1, 5),\n    z=LinSpace(0, 1, 6),\n    w=LogSpace(0, 1, 7),\n)\nprint(tensor.shape)\n</code></pre> <p>As we noted above, the einmesh pattern can be reused across different backends. Making it easy to switch between them without any changes other than an import. </p> <pre><code>from einmesh.jax import einmesh as einmesh_jax\nfrom einmesh.numpy import einmesh as einmesh_np\nfrom einmesh.torch import einmesh as einmesh_torch\n\n# np example\nnp_tensor = einmesh_np(\n    \"(x *) (... y) z y w w\",\n    *([LinSpace(1, 1, 5)] * 3),\n    x=LinSpace(0, 2, 3),\n    y=NormalDistribution(0, 1, 5),\n    z=LinSpace(0, 1, 6),\n    w=LogSpace(0, 1, 7),\n)\nprint(type(np_tensor))\nprint(np_tensor.shape)\n\n# jax example\njax_tensor = einmesh_jax(\n    \"(x *) (... y) z y w w\",\n    *([LinSpace(1, 1, 5)] * 3),\n    x=LinSpace(0, 2, 3),\n    y=NormalDistribution(0, 1, 5),\n    z=LinSpace(0, 1, 6),\n    w=LogSpace(0, 1, 7),\n)\nprint(type(jax_tensor))\nprint(jax_tensor.shape)\n\n# torch example\ntorch_tensor = einmesh_torch(\n    \"(x *) (... y) z y w w\",\n    *([LinSpace(1, 1, 5)] * 3),\n    x=LinSpace(0, 2, 3),\n    y=NormalDistribution(0, 1, 5),\n    z=LinSpace(0, 1, 6),\n    w=LogSpace(0, 1, 7),\n)\nprint(type(torch_tensor))\nprint(torch_tensor.shape)\n</code></pre>"},{"location":"notebooks/comparison_with_meshgrids/","title":"Comparison between meshgrid and einmesh","text":"<p>In this example we are going to show some of the justifying examples where i think einmesh makes code more readable, more maintainable and just simply shorter than the current standard meshgrid function. </p> <pre><code>import numpy as np\nimport torch\n\n# Import einmesh for comparisons\nfrom einmesh import LinSpace\nfrom einmesh.numpy import einmesh as einmesh_np\nfrom einmesh.torch import einmesh as einmesh_torch\n</code></pre>"},{"location":"notebooks/comparison_with_meshgrids/#direct-comparisons-meshgrid-vs-einmesh","title":"Direct comparisons: meshgrid vs einmesh","text":"<p>For each common use case, we'll show the traditional meshgrid approach followed immediately by the einmesh equivalent.</p>"},{"location":"notebooks/comparison_with_meshgrids/#example-1-simple-2d-grid-numpy","title":"Example 1: Simple 2D grid (NumPy)","text":"<p>Traditional meshgrid approach:</p> <p>The most common pattern for using a meshgrid function is probably for plotting a 2D surface. The standard way to do this is some variation of the below:</p> <pre><code># Traditional NumPy meshgrid - 3 lines\nx = np.linspace(0, 10, 11)\ny = np.linspace(0, 5, 6)\nX, Y = np.meshgrid(x, y, indexing=\"ij\")\n\nprint(\"Traditional 2D grid:\")\nprint(f\"X shape: {X.shape}\")\nprint(f\"Y shape: {Y.shape}\")\n</code></pre> <p>Here there are a couple of annoyances with this approach 1. Usually there are two variables assigned with almost the same name, x,y and X,Y. This is to differentiate between the linspace that meshgrid takes in, and the dimension that is actually being output.  2. Indexing has to be specified, and it is not obvious from reading the code what the difference between the differnt indexing methods are 3. The whole thing realies on positional arguments, which maybe acceptable with dimensions, but become really cumbersome for error-prone for very high dimensional use. </p> <p>einmesh equivalent:</p> <pre><code># einmesh - 1 line, same result\nX_ein, Y_ein = einmesh_np(\"x y\", x=LinSpace(0, 10, 11), y=LinSpace(0, 5, 6))\n\nprint(\"einmesh 2D grid:\")\nprint(f\"X shape: {X_ein.shape}\")\nprint(f\"Y shape: {Y_ein.shape}\")\nprint(\"Results identical:\", np.allclose(X, X_ein) and np.allclose(Y, Y_ein))\n</code></pre>"},{"location":"notebooks/comparison_with_meshgrids/#example-2-3d-grid-with-stacking-numpy","title":"Example 2: 3D grid with stacking (NumPy)","text":"<p>Traditional meshgrid approach:</p> <p>Another common pattern is to need to stack the output dimsions of a meshgrid. In this case with 3 dimensions, we start to see how easily it could be to make a mistake in the x,y,z positions, both in the definitions, arguments, unpacking and stacking. Furthermore we have the common problem </p> <pre><code># Traditional NumPy meshgrid - 5 lines\nx = np.linspace(-2, 2, 5)\ny = np.linspace(-1, 1, 3)\nz = np.linspace(0, 3, 4)\nX, Y, Z = np.meshgrid(x, y, z, indexing=\"ij\")\ncoords_traditional = np.stack([X, Y, Z], axis=-1)\n\nprint(\"Traditional 3D stacked grid:\")\nprint(f\"Coordinates shape: {coords_traditional.shape}\")\nprint(\"5 lines of code\")\n</code></pre> <p>The code above is great at describing what is happening, but is not ideal for describing what is going to come out of all these operations. Just like einops, einmesh focuses on what is comming in and out, not what is happening under the hood. </p> <p>Thus in einmesh we can stack simply with the star operator, it is clear where the dimensions are collected and can easily relate the dimensions through the use of keyword arguments.</p> <pre><code># einmesh - 1 line, automatic stacking with '*'\ncoords_ein = einmesh_np(\"x y z *\", x=LinSpace(-2, 2, 5), y=LinSpace(-1, 1, 3), z=LinSpace(0, 3, 4))\n\nprint(\"einmesh 3D stacked grid:\")\nprint(f\"Coordinates shape: {coords_ein.shape}\")\nprint(\"Results identical:\", np.allclose(coords_traditional, coords_ein))\n</code></pre>"},{"location":"notebooks/comparison_with_meshgrids/#example-6-batch-processing-with-stacked-coordinates-pytorch","title":"Example 6: Batch processing with stacked coordinates (PyTorch)","text":"<p>Traditional meshgrid approach:</p> <pre><code># Traditional PyTorch meshgrid - 8+ lines for multiple grids\nbatch_sizes = [32, 64, 128]\ngrids_traditional = []\n\nfor size in batch_sizes:\n    x = torch.linspace(0, 1, size)\n    y = torch.linspace(0, 1, size)\n    X, Y = torch.meshgrid(x, y, indexing=\"ij\")\n    grid = torch.stack([X, Y], dim=-1)\n    grids_traditional.append(grid)\n    print(f\"Traditional grid {size}x{size} shape: {grid.shape}\")\n</code></pre> <p>einmesh equivalent:</p> <pre><code># einmesh - 4 lines with automatic stacking via '*'\ngrids_ein = []\nfor size in [32, 64, 128]:\n    grid = einmesh_torch(\"x y *\", x=LinSpace(0, 1, size), y=LinSpace(0, 1, size))\n    grids_ein.append(grid)\n    print(f\"einmesh grid {size}x{size} shape: {grid.shape}\")\n\nprint(\"Results identical:\", all(torch.allclose(trad, ein) for trad, ein in zip(grids_traditional, grids_ein)))\n</code></pre> <pre><code>\n</code></pre> <p>= Your code becomes more backend agnostic</p> <p>Just like with einops, einmesh supports multiple matrix and tensor backends. This can feel like a small thing, but knowing that some complicated piece of code instantly works in numpy or jax, if you want to try, gives a flexibility that makes experiments a little more </p> <pre><code>from einmesh.jax import einmesh as einmesh_jax\n\n# Example: Same einmesh pattern across different backends\n\n# Define a common grid pattern\npattern = \"x y *\"\nx_space = LinSpace(-1, 1, 50)\ny_space = LinSpace(-2, 2, 30)\n\n# NumPy backend\ncoords_numpy = einmesh_np(pattern, x=x_space, y=y_space)\nprint(\"NumPy backend:\")\nprint(f\"  Shape: {coords_numpy.shape}\")\nprint(f\"  Type: {type(coords_numpy)}\")\nprint(\"  Backend: numpy\")\n\n# PyTorch backend\ncoords_torch = einmesh_torch(pattern, x=x_space, y=y_space)\nprint(\"\\nPyTorch backend:\")\nprint(f\"  Shape: {coords_torch.shape}\")\nprint(f\"  Type: {type(coords_torch)}\")\nprint(\"  Backend: torch\")\n\ncoords_jax = einmesh_jax(pattern, x=x_space, y=y_space)\nprint(\"\\nJAX backend:\")\nprint(f\"  Shape: {coords_jax.shape}\")\nprint(f\"  Type: {type(coords_jax)}\")\nprint(\"  Backend: jax\")\n\n# Verify results are equivalent\nprint(\n    f\"\\nAll backends produce identical results: {np.allclose(coords_numpy, np.array(coords_jax)) and np.allclose(coords_numpy, coords_torch.numpy())}\"\n)\n</code></pre>"}]}